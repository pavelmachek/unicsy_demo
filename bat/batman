#!/usr/bin/python3
# -*- python -*-

from __future__ import print_function

import sys
sys.path += [ "/usr/share/unicsy/lib", "../lib" ]

import os
import time
import hardware
import watchdog
import sys
import select
import termios
import tty
import time
import datetime

def get_char(t):
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        i, o, e = select.select([sys.stdin], [], [], t)
        if i:
            char = sys.stdin.read(1)
        else:
            char = None
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return char

# For recording past charge states
class State:
    def __init__(m, bat):
        m.volt = bat.volt
        m.perc = bat.perc
        m.volt3 = bat.volt3
        m.perc3 = bat.perc3
        m.charge_counter = bat.charge_counter
        m.time = time.time()
        m.status = bat.status

class Man:
    def esc(m, s):
        print(chr(27)+s)

    def cls(m):
        m.esc("c")

    def disp(m, v):
        if v in m.states:
            old = m.states[v]
            dt = time.time() - old.time
            dc = (m.bat.charge_counter - old.charge_counter) / 1000
            print(v, "%.1f min ago" % (dt/60),
                  "%.6f Ah" % dc,
                  "%.6f A" % ((dc * 3600.)/dt) )

    def perc(m, p):
        p = int(p/3)
        return '#'*p + '.'*(34-p)

    def battery_details(m):
        bat = m.bat
        print()
        print("Battery")
        # current_avg: Librem 5 displays > 0 for discharge. should be other way around iirc.
        print("  current now %.3f A avg %.3f A %.3f Ah (>0: charging)" % (bat.current/1000, bat.current_avg/1000, bat.charge_counter/1000))
        temp = m.bat.read_int(m.bat.battery + "/temp") / 10.
        voltage_ocv = m.bat.read_int(m.bat.battery + "/voltage_ocv")
        print("  temperature %.1f C int %.2fV" % (temp, voltage_ocv / 1000000))

    def charger_details(m):
        bat = m.bat
        print()
        print("Charger")
        cc_current = m.bat.read_int(m.bat.charger + "/constant_charge_current")
        cc_voltage = m.bat.read_int(m.bat.charger + "/constant_charge_voltage")
        limit_current = m.bat.read_int(m.bat.charger + "/input_current_limit")
        current = m.bat.read_int(m.bat.charger + "/current_now")
        print("  cc %.2f V %.3f A i/limit %.3f A" % (cc_voltage/1000000, cc_current/1000000, limit_current/1000000))

        temp = m.bat.read_int(m.bat.charger + "/temp") / 10.
        print("  temperature %.1f C" % (temp))

        voltage = m.bat.read_int(m.bat.charger + "/voltage_now")
        current = m.bat.read_int(m.bat.charger + "/current_now")
        # On l5, these seem to mirror battery values, so not terribly interesting
        print("  now %.2f V %.3f A" % (voltage/1000000, current/1000000))

    def one_step(m):
        bat = m.bat
        bat.run()
        s = bat.summary()
        s2 = bat.handle_protect()
        if s2: s = s2

        if m.last_counter is None:
            aacur = 0
        else:
            # in mAh
            aacur = (m.last_counter - bat.charge_counter) / (m.step/3600.)
            # WTF? Is that right?
        m.last_counter = bat.charge_counter

        if not "startup" in m.states:
            m.states["startup"] = State(bat)
        if "last" in m.states:
            ls = m.states["last"].status
            if bat.status != ls:
                m.states[ls + "-" + bat.status] = State(bat)
            def cvt(x): return int(x*10)
            p2 = cvt(bat.volt)
            p1 = cvt(m.states["last"].volt)
            #print("---", p1, p2)
            if p1 != p2:
                m.states["%s%d-%d" % (bat.status, p1, p2)] = State(bat)

        if False:
            print("utime=%.3f"% time.time(),
                  "batvolt=%.3f" % bat.volt,
                  "bativolt=%.3f" % bat.volt3,
                  "batperc=%.1f" % bat.perc,
                  "batiperc=%.1f" % bat.perc3,
                  "batcur=%.5f" % bat.current,
                  "batacur=%.5f" % bat.current_avg,
                  "bataacur=%f" % aacur,
                  "charge=%f" % bat.charge_counter, file=bat_log)
        if True:
            m.capacity = 1785
            if bat.battery_empty and bat.battery_full:
                m.capacity = bat.battery_full-bat.battery_empty

            percent = m.bat.read_int(m.bat.battery + "/capacity")
            print("kernel     %.0f %% |%s" % (percent, m.perc(percent)))
            print("bat %.2f V %.0f %% |%s" % (bat.volt, bat.perc, m.perc(bat.perc)))
            print("int %.2f V %.0f %% |%s" % (bat.volt3, bat.perc3, m.perc(bat.perc3)))

            # This is attempt to get useful data from charge counter
            v = "Full-Discharging"
            if v in m.states:
                old = m.states[v]
                # Full -- 75% at 4.1V
                base_charge = old.charge_counter
            else:
                base_charge = 496.266 + 157.13 + 67.47
            dc = (m.bat.charge_counter - base_charge) / 1000
            cap = 1.1 # Assuming 900mAh from 71% to zero.
            p = 70 + 70 * (dc / cap)
            if p < 0: p = 0
            if p > 100: p = 100
            print("%2.5f Ah %.0f %% |%s" % (dc, p, m.perc(p)))

            # Display currents, etc:
            m.battery_details()
            m.charger_details()

            # These are attempts to time how long various charge thresholds are reached
            print()
            print("st %s b_st %s" % (bat.status, bat.b_status))
            m.disp("Full-Discharging")
            m.disp("Charging-Discharging")
            m.disp("Discharging-Charging")
            m.disp("Charging-Full")
            m.disp("startup")
            m.disp("Discharging40-39")
            m.disp("Discharging39-38")
            m.disp("Discharging38-37")
            m.disp("Discharging37-36")
            m.disp("Discharging36-35")
            m.disp("Discharging35-34")
            m.disp("Discharging34-33")
            m.disp("Charging35-36")
            m.disp("Charging36-37")
            m.disp("Charging37-38")
            m.disp("Charging38-39")
            m.disp("Charging39-40")
            #print(m.states)

        if False:
            print("empty %s 3.5V %s 4V %s full %s |" % (bat.fmt(bat.battery_empty), bat.fmt(bat.battery_35V), bat.fmt(bat.battery_4V), bat.fmt(bat.battery_full)), file=sys.stderr)

            print(bat.guess_charge(bat.battery_empty, 0, m.capacity) + " to empty", file=sys.stderr)
            print(bat.guess_charge(bat.battery_35V, bat.percent(3.5) / 100., m.capacity) + " to 3.5V", file=sys.stderr)
            print(bat.guess_charge(bat.battery_4V, bat.percent(4.) / 100., m.capacity) + " or more -- to 4V", file=sys.stderr)
            print(bat.guess_charge(bat.battery_full, 1., m.capacity) + " to full", file=sys.stderr)

        m.states["last"] = State(bat)

    def set_chg_current(m, amp):
        amp *= 1000
        amp = int(amp)
        # This was designed for d4:
        if hardware.hw.d4:
            os.system("echo %d | sudo tee %s/input_current_limit" % (amp, m.bat.charger))
        else:
            os.system("echo %d | sudo tee %s/constant_charge_current" % (amp, m.bat.charger))

    def set_chg_voltage(m, volt):
        volt *= 1000
        volt = int(volt)
        os.system("echo %d | sudo tee %s/constant_charge_voltage" % (volt, m.bat.charger))        

    def set_charge(m, amp, volt):
        m.set_chg_current(amp)
        m.set_chg_voltage(volt)
        
    def handle_cmd(m, c):
        if not c:
            return
        if ord(c) == 3:
            exit(0)

        print()
        if c == '`': m.set_chg_current(100) 
        if c == '1': m.set_chg_current(200)
        if c == '2': m.set_chg_current(500)
        if c == '3': m.set_chg_current(800)
        if c == '4': m.set_chg_current(1200) 
        if c == '5': m.set_chg_current(1900) 

        # Droid 4 can't do most of these.
        # Librem 5 can't do 3800
        if c == '6': m.set_chg_voltage(3870)   # to 60%
        if c == '7': m.set_chg_voltage(3950)   # to 70%
        if c == '8': m.set_chg_voltage(4005)   # to 80%
        if c == '9': m.set_chg_voltage(4150)   # to 90%
        if c == '0': m.set_chg_voltage(4210)   # to 100%
        if c == '-':
            if hardware.hw.d4:
                m.set_chg_voltage(4349)
                # OnePlus 6 uses 4359869
            else:
                print("Boost not available outside d4")
        if c == 'q': sys.exit(0)

        print("Current limit (d4): ", m.bat.read_int(m.bat.charger + "/input_current_limit"))
        print("Current limit (l5): ", m.bat.read_int(m.bat.charger + "/constant_charge_current"))
        print("Voltage limit: ", m.bat.read_int(m.bat.charger + "/constant_charge_voltage"))
        time.sleep(1)

    def run(m):
        m.bat = hardware.hw.battery
        m.last_counter = None
        m.states = {}
        m.step = 60
        while 1:
            m.cls()
            m.one_step()
            sys.stdout.flush()
            c = get_char(m.step)
            m.handle_cmd(c)

class Auto(Man):
    def battery_details(m):
        bat = m.bat
        # current_avg: Librem 5 displays > 0 for discharge. should be other way around iirc.
        print("%.3f A" % (bat.current/1000), end='')
        temp = m.bat.read_int(m.bat.battery + "/temp") / 10.
        print(" %.1f C " % temp, end='')

    def charger_details(m):
        bat = m.bat
        cc_current = m.bat.read_int(m.bat.charger + "/constant_charge_current")
        cc_voltage = m.bat.read_int(m.bat.charger + "/constant_charge_voltage")
        limit_current = m.bat.read_int(m.bat.charger + "/input_current_limit")
        current = m.bat.read_int(m.bat.charger + "/current_now")
        print("cc%.2fV %.3fA i%.3fA" % (cc_voltage/1000000, cc_current/1000000, limit_current/1000000), end='')

    # Give me code to estimate time neccessary "C" factor (charge
    # current) given current percentage, target percentage, time
    # available.
    def required_c_rate(m, capacity_mAh: float, soc_now: float, soc_target: float,
                        time_hours: float, cv_factor: float = 3.0) -> float:
        """
        Estimate necessary C-rate to reach soc_target from soc_now in time_hours.
        Includes CC + CV phases.

        capacity_mAh : nominal cell capacity in mAh (e.g. 3000)
        soc_now      : current SOC (%)
        soc_target   : target SOC (%)
        time_hours   : time available (hours)
        cv_factor    : slowdown multiplier for SOC above 80% (default 3.0)

        Returns: required C-rate (float).
        """
        if soc_target <= soc_now:
            return 0

        soc_cc_start = max(soc_now, 0)
        soc_cc_end   = min(soc_target, 80.0)
        soc_cv_start = max(soc_now, 80.0)
        soc_cv_end   = soc_target

        # CC part (linear)
        delta_cc = max(0.0, soc_cc_end - soc_cc_start) / 100.0
        energy_cc = capacity_mAh * delta_cc

        # CV part (slower)
        delta_cv = max(0.0, soc_cv_end - soc_cv_start) / 100.0
        energy_cv = capacity_mAh * delta_cv

        # Effective time requirement per mAh
        # CV is slower: multiply time per mAh by cv_factor
        effective_mAh = energy_cc + cv_factor * energy_cv

        # Required current (mA) to fit within time_hours
        current_mA = effective_mAh / time_hours
        c_rate = current_mA / capacity_mAh
        return c_rate

    def one_step(m):
        now = datetime.datetime.now()
        print(now.strftime("%H:%M "), end='')

        bat = m.bat
        bat.run()
        s = bat.summary()

        percent = m.bat.read_int(m.bat.battery + "/capacity")
        print("%.0f%% (" % (percent), end='')
        print("%.2fV " % bat.volt, end='')
        print("i %.2fV %.0f%%) " % (bat.volt3, bat.perc3), end='')

        # Display currents, etc:
        m.battery_details()
        m.charger_details()

        # Design capacity
        capacity = 5000
        c_rate = 0
        
        if m.target_time > 0:
            hours = (m.target_time - time.time()) / (60*60)
            c_rate = m.required_c_rate(5000, percent, m.target_perc, hours)
            print(" %.1fh %.2f C" % (hours, c_rate))
            if c_rate < 0.05:
                c_rate = 0
        if m.target_time < 0:
            c_rate = 0.1

        amp = capacity * c_rate
        print(" -> %.2f C, %.0fmA" % (c_rate, amp))
        m.set_chg_current(amp)

    def run(m):
        m.bat = hardware.hw.battery

        if m.target_perc < 80: m.set_chg_voltage(3870)
        if m.target_perc >= 80: m.set_chg_voltage(4005)

        m.one_step()
        time.sleep(3)
        while 1:
            m.one_step()
            sys.stdout.flush()
            time.sleep(60)

def parse_time_arg(arg: str) -> int:
    """Parse HH:MM and return Unix timestamp (seconds)."""
    try:
        hour, minute = map(int, arg.split(":"))
    except ValueError:
        return -1

    now = datetime.datetime.now()
    target = now.replace(hour=hour, minute=minute, second=0, microsecond=0)

    # If target time already passed today, use tomorrow
    if target <= now:
        target += datetime.timedelta(days=1)

    return int(target.timestamp())

def help():
    print("Usage: script.py [-m] | [HH:MM]")
    
def parse(arg):
    if arg == "-m":
        print("Manual mode")
        m = Man()
        m.run()
        return 0
    if arg == "min":
        print("should do .1C charge to 60%")        
        m = Auto()
        m.target_time = -1
        m.target_perc = 60
        m.run()
        return 0
    t = parse_time_arg(arg)
    if t > 0:
        print(f"Target Unix time: {t}")
        m = Auto()
        m.target_time = t
        m.target_perc = 80
        m.run()
        return 0
    help()

def main():
    if len(sys.argv) > 1:
        parse(sys.argv[1])
        return
    help()
    
if __name__ == "__main__":
    main()
